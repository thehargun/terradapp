{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bech32m = exports.bech32 = void 0;\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst ALPHABET_MAP = {};\n\nfor (let z = 0; z < ALPHABET.length; z++) {\n  const x = ALPHABET.charAt(z);\n  ALPHABET_MAP[x] = z;\n}\n\nfunction polymodStep(pre) {\n  const b = pre >> 25;\n  return (pre & 0x1ffffff) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;\n}\n\nfunction prefixChk(prefix) {\n  let chk = 1;\n\n  for (let i = 0; i < prefix.length; ++i) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';\n    chk = polymodStep(chk) ^ c >> 5;\n  }\n\n  chk = polymodStep(chk);\n\n  for (let i = 0; i < prefix.length; ++i) {\n    const v = prefix.charCodeAt(i);\n    chk = polymodStep(chk) ^ v & 0x1f;\n  }\n\n  return chk;\n}\n\nfunction convert(data, inBits, outBits, pad) {\n  let value = 0;\n  let bits = 0;\n  const maxV = (1 << outBits) - 1;\n  const result = [];\n\n  for (let i = 0; i < data.length; ++i) {\n    value = value << inBits | data[i];\n    bits += inBits;\n\n    while (bits >= outBits) {\n      bits -= outBits;\n      result.push(value >> bits & maxV);\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push(value << outBits - bits & maxV);\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding';\n    if (value << outBits - bits & maxV) return 'Non-zero padding';\n  }\n\n  return result;\n}\n\nfunction toWords(bytes) {\n  return convert(bytes, 8, 5, true);\n}\n\nfunction fromWordsUnsafe(words) {\n  const res = convert(words, 5, 8, false);\n  if (Array.isArray(res)) return res;\n}\n\nfunction fromWords(words) {\n  const res = convert(words, 5, 8, false);\n  if (Array.isArray(res)) return res;\n  throw new Error(res);\n}\n\nfunction getLibraryFromEncoding(encoding) {\n  let ENCODING_CONST;\n\n  if (encoding === 'bech32') {\n    ENCODING_CONST = 1;\n  } else {\n    ENCODING_CONST = 0x2bc830a3;\n  }\n\n  function encode(prefix, words, LIMIT) {\n    LIMIT = LIMIT || 90;\n    if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');\n    prefix = prefix.toLowerCase(); // determine chk mod\n\n    let chk = prefixChk(prefix);\n    if (typeof chk === 'string') throw new Error(chk);\n    let result = prefix + '1';\n\n    for (let i = 0; i < words.length; ++i) {\n      const x = words[i];\n      if (x >> 5 !== 0) throw new Error('Non 5-bit word');\n      chk = polymodStep(chk) ^ x;\n      result += ALPHABET.charAt(x);\n    }\n\n    for (let i = 0; i < 6; ++i) {\n      chk = polymodStep(chk);\n    }\n\n    chk ^= ENCODING_CONST;\n\n    for (let i = 0; i < 6; ++i) {\n      const v = chk >> (5 - i) * 5 & 0x1f;\n      result += ALPHABET.charAt(v);\n    }\n\n    return result;\n  }\n\n  function __decode(str, LIMIT) {\n    LIMIT = LIMIT || 90;\n    if (str.length < 8) return str + ' too short';\n    if (str.length > LIMIT) return 'Exceeds length limit'; // don't allow mixed case\n\n    const lowered = str.toLowerCase();\n    const uppered = str.toUpperCase();\n    if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;\n    str = lowered;\n    const split = str.lastIndexOf('1');\n    if (split === -1) return 'No separator character for ' + str;\n    if (split === 0) return 'Missing prefix for ' + str;\n    const prefix = str.slice(0, split);\n    const wordChars = str.slice(split + 1);\n    if (wordChars.length < 6) return 'Data too short';\n    let chk = prefixChk(prefix);\n    if (typeof chk === 'string') return chk;\n    const words = [];\n\n    for (let i = 0; i < wordChars.length; ++i) {\n      const c = wordChars.charAt(i);\n      const v = ALPHABET_MAP[c];\n      if (v === undefined) return 'Unknown character ' + c;\n      chk = polymodStep(chk) ^ v; // not in the checksum?\n\n      if (i + 6 >= wordChars.length) continue;\n      words.push(v);\n    }\n\n    if (chk !== ENCODING_CONST) return 'Invalid checksum for ' + str;\n    return {\n      prefix,\n      words\n    };\n  }\n\n  function decodeUnsafe(str, LIMIT) {\n    const res = __decode(str, LIMIT);\n\n    if (typeof res === 'object') return res;\n  }\n\n  function decode(str, LIMIT) {\n    const res = __decode(str, LIMIT);\n\n    if (typeof res === 'object') return res;\n    throw new Error(res);\n  }\n\n  return {\n    decodeUnsafe,\n    decode,\n    encode,\n    toWords,\n    fromWordsUnsafe,\n    fromWords\n  };\n}\n\nexports.bech32 = getLibraryFromEncoding('bech32');\nexports.bech32m = getLibraryFromEncoding('bech32m');","map":{"version":3,"sources":["C:/Users/hargu/Desktop/Luna Classic/LunaClassic/node_modules/bech32/dist/index.js"],"names":["Object","defineProperty","exports","value","bech32m","bech32","ALPHABET","ALPHABET_MAP","z","length","x","charAt","polymodStep","pre","b","prefixChk","prefix","chk","i","c","charCodeAt","v","convert","data","inBits","outBits","pad","bits","maxV","result","push","toWords","bytes","fromWordsUnsafe","words","res","Array","isArray","fromWords","Error","getLibraryFromEncoding","encoding","ENCODING_CONST","encode","LIMIT","TypeError","toLowerCase","__decode","str","lowered","uppered","toUpperCase","split","lastIndexOf","slice","wordChars","undefined","decodeUnsafe","decode"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bech32m = exports.bech32 = void 0;\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst ALPHABET_MAP = {};\nfor (let z = 0; z < ALPHABET.length; z++) {\n    const x = ALPHABET.charAt(z);\n    ALPHABET_MAP[x] = z;\n}\nfunction polymodStep(pre) {\n    const b = pre >> 25;\n    return (((pre & 0x1ffffff) << 5) ^\n        (-((b >> 0) & 1) & 0x3b6a57b2) ^\n        (-((b >> 1) & 1) & 0x26508e6d) ^\n        (-((b >> 2) & 1) & 0x1ea119fa) ^\n        (-((b >> 3) & 1) & 0x3d4233dd) ^\n        (-((b >> 4) & 1) & 0x2a1462b3));\n}\nfunction prefixChk(prefix) {\n    let chk = 1;\n    for (let i = 0; i < prefix.length; ++i) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            return 'Invalid prefix (' + prefix + ')';\n        chk = polymodStep(chk) ^ (c >> 5);\n    }\n    chk = polymodStep(chk);\n    for (let i = 0; i < prefix.length; ++i) {\n        const v = prefix.charCodeAt(i);\n        chk = polymodStep(chk) ^ (v & 0x1f);\n    }\n    return chk;\n}\nfunction convert(data, inBits, outBits, pad) {\n    let value = 0;\n    let bits = 0;\n    const maxV = (1 << outBits) - 1;\n    const result = [];\n    for (let i = 0; i < data.length; ++i) {\n        value = (value << inBits) | data[i];\n        bits += inBits;\n        while (bits >= outBits) {\n            bits -= outBits;\n            result.push((value >> bits) & maxV);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            result.push((value << (outBits - bits)) & maxV);\n        }\n    }\n    else {\n        if (bits >= inBits)\n            return 'Excess padding';\n        if ((value << (outBits - bits)) & maxV)\n            return 'Non-zero padding';\n    }\n    return result;\n}\nfunction toWords(bytes) {\n    return convert(bytes, 8, 5, true);\n}\nfunction fromWordsUnsafe(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n}\nfunction fromWords(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n    throw new Error(res);\n}\nfunction getLibraryFromEncoding(encoding) {\n    let ENCODING_CONST;\n    if (encoding === 'bech32') {\n        ENCODING_CONST = 1;\n    }\n    else {\n        ENCODING_CONST = 0x2bc830a3;\n    }\n    function encode(prefix, words, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (prefix.length + 7 + words.length > LIMIT)\n            throw new TypeError('Exceeds length limit');\n        prefix = prefix.toLowerCase();\n        // determine chk mod\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            throw new Error(chk);\n        let result = prefix + '1';\n        for (let i = 0; i < words.length; ++i) {\n            const x = words[i];\n            if (x >> 5 !== 0)\n                throw new Error('Non 5-bit word');\n            chk = polymodStep(chk) ^ x;\n            result += ALPHABET.charAt(x);\n        }\n        for (let i = 0; i < 6; ++i) {\n            chk = polymodStep(chk);\n        }\n        chk ^= ENCODING_CONST;\n        for (let i = 0; i < 6; ++i) {\n            const v = (chk >> ((5 - i) * 5)) & 0x1f;\n            result += ALPHABET.charAt(v);\n        }\n        return result;\n    }\n    function __decode(str, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (str.length < 8)\n            return str + ' too short';\n        if (str.length > LIMIT)\n            return 'Exceeds length limit';\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        const uppered = str.toUpperCase();\n        if (str !== lowered && str !== uppered)\n            return 'Mixed-case string ' + str;\n        str = lowered;\n        const split = str.lastIndexOf('1');\n        if (split === -1)\n            return 'No separator character for ' + str;\n        if (split === 0)\n            return 'Missing prefix for ' + str;\n        const prefix = str.slice(0, split);\n        const wordChars = str.slice(split + 1);\n        if (wordChars.length < 6)\n            return 'Data too short';\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            return chk;\n        const words = [];\n        for (let i = 0; i < wordChars.length; ++i) {\n            const c = wordChars.charAt(i);\n            const v = ALPHABET_MAP[c];\n            if (v === undefined)\n                return 'Unknown character ' + c;\n            chk = polymodStep(chk) ^ v;\n            // not in the checksum?\n            if (i + 6 >= wordChars.length)\n                continue;\n            words.push(v);\n        }\n        if (chk !== ENCODING_CONST)\n            return 'Invalid checksum for ' + str;\n        return { prefix, words };\n    }\n    function decodeUnsafe(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n    }\n    function decode(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n        throw new Error(res);\n    }\n    return {\n        decodeUnsafe,\n        decode,\n        encode,\n        toWords,\n        fromWordsUnsafe,\n        fromWords,\n    };\n}\nexports.bech32 = getLibraryFromEncoding('bech32');\nexports.bech32m = getLibraryFromEncoding('bech32m');\n"]},"metadata":{},"sourceType":"script"}