{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompactBitArray = void 0;\n\nvar multisig_1 = require(\"@terra-money/terra.proto/cosmos/crypto/multisig/v1beta1/multisig\");\n\nvar CompactBitArray =\n/** @class */\nfunction () {\n  function CompactBitArray(extra_bits_stored, elems) {\n    this.extra_bits_stored = extra_bits_stored;\n    this.elems = elems;\n  }\n\n  CompactBitArray.fromBits = function (bits) {\n    if (bits <= 0) {\n      throw new Error('CompactBitArray bits must be bigger than 0');\n    }\n\n    var num_elems = (bits + 7) / 8;\n\n    if (num_elems <= 0 || num_elems > Math.pow(2, 32) - 1) {\n      // We encountered an overflow here, and shouldn't pass negatives\n      // to make, nor should we allow unreasonable limits > maxint32.\n      // See https://github.com/cosmos/cosmos-sdk/issues/9162\n      throw new Error('CompactBitArray overflow');\n    }\n\n    return new CompactBitArray(bits % 8, Buffer.alloc(num_elems));\n  }; // returns the number of bits in the bitarray\n\n\n  CompactBitArray.prototype.count = function () {\n    if (this.extra_bits_stored == 0) {\n      return this.elems.length * 8;\n    }\n\n    return (this.elems.length - 1) * 8 + this.extra_bits_stored;\n  }; // returns true if the bit at index i is set; returns false otherwise.\n  // The behavior is undefined if i >= bA.Count()\n\n\n  CompactBitArray.prototype.getIndex = function (i) {\n    if (i < 0 || i >= this.count()) {\n      return false;\n    }\n\n    return (this.elems.readUInt8(i >> 3) & 1 << 7 - i % 8) > 0;\n  }; // sets the bit at index i within the bit array. Returns true if and only if the\n  // operation succeeded. The behavior is undefined if i >= bA.Count()\n\n\n  CompactBitArray.prototype.setIndex = function (i, v) {\n    if (i < 0 || i >= this.count()) {\n      return false;\n    }\n\n    if (v) {\n      this.elems[i >> 3] |= 1 << 7 - i % 8;\n    } else {\n      this.elems[i >> 3] &= ~(1 << 7 - i % 8);\n    }\n\n    return true;\n  }; // returns the number of bits set to true before the\n  // given index. e.g. if bA = _XX__XX, NumOfTrueBitsBefore(4) = 2, since\n  // there are two bits set to true before index 4.\n\n\n  CompactBitArray.prototype.numTrueBitsBefore = function (index) {\n    var countOneBits = function (n) {\n      return n.toString(2).split('0').join('').length;\n    };\n\n    var ones_count = 0;\n    var max = this.count();\n\n    if (index > max) {\n      index = max;\n    } // below we iterate over the bytes then over bits (in low endian) and count bits set to 1\n\n\n    for (var elem = 0;; elem++) {\n      if (elem * 8 + 7 >= index) {\n        ones_count += countOneBits(this.elems[elem] >> 7 - index % 8 + 1);\n        return ones_count;\n      }\n\n      ones_count += countOneBits(this.elems[elem]);\n    }\n  };\n\n  CompactBitArray.fromData = function (data) {\n    return new CompactBitArray(data.extra_bits_stored, Buffer.from(data.elems, 'base64'));\n  };\n\n  CompactBitArray.prototype.toData = function () {\n    return {\n      elems: this.elems.toString('base64'),\n      extra_bits_stored: this.extra_bits_stored\n    };\n  };\n\n  CompactBitArray.fromProto = function (proto) {\n    return new CompactBitArray(proto.extraBitsStored, Buffer.from(proto.elems));\n  };\n\n  CompactBitArray.prototype.toProto = function () {\n    return multisig_1.CompactBitArray.fromPartial({\n      elems: this.elems,\n      extraBitsStored: this.extra_bits_stored\n    });\n  };\n\n  return CompactBitArray;\n}();\n\nexports.CompactBitArray = CompactBitArray;","map":{"version":3,"sources":["../../src/core/CompactBitArray.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CompactBitArray = void 0;\nvar multisig_1 = require(\"@terra-money/terra.proto/cosmos/crypto/multisig/v1beta1/multisig\");\nvar CompactBitArray = /** @class */ (function () {\n    function CompactBitArray(extra_bits_stored, elems) {\n        this.extra_bits_stored = extra_bits_stored;\n        this.elems = elems;\n    }\n    CompactBitArray.fromBits = function (bits) {\n        if (bits <= 0) {\n            throw new Error('CompactBitArray bits must be bigger than 0');\n        }\n        var num_elems = (bits + 7) / 8;\n        if (num_elems <= 0 || num_elems > Math.pow(2, 32) - 1) {\n            // We encountered an overflow here, and shouldn't pass negatives\n            // to make, nor should we allow unreasonable limits > maxint32.\n            // See https://github.com/cosmos/cosmos-sdk/issues/9162\n            throw new Error('CompactBitArray overflow');\n        }\n        return new CompactBitArray(bits % 8, Buffer.alloc(num_elems));\n    };\n    // returns the number of bits in the bitarray\n    CompactBitArray.prototype.count = function () {\n        if (this.extra_bits_stored == 0) {\n            return this.elems.length * 8;\n        }\n        return (this.elems.length - 1) * 8 + this.extra_bits_stored;\n    };\n    // returns true if the bit at index i is set; returns false otherwise.\n    // The behavior is undefined if i >= bA.Count()\n    CompactBitArray.prototype.getIndex = function (i) {\n        if (i < 0 || i >= this.count()) {\n            return false;\n        }\n        return (this.elems.readUInt8(i >> 3) & (1 << (7 - (i % 8)))) > 0;\n    };\n    // sets the bit at index i within the bit array. Returns true if and only if the\n    // operation succeeded. The behavior is undefined if i >= bA.Count()\n    CompactBitArray.prototype.setIndex = function (i, v) {\n        if (i < 0 || i >= this.count()) {\n            return false;\n        }\n        if (v) {\n            this.elems[i >> 3] |= 1 << (7 - (i % 8));\n        }\n        else {\n            this.elems[i >> 3] &= ~(1 << (7 - (i % 8)));\n        }\n        return true;\n    };\n    // returns the number of bits set to true before the\n    // given index. e.g. if bA = _XX__XX, NumOfTrueBitsBefore(4) = 2, since\n    // there are two bits set to true before index 4.\n    CompactBitArray.prototype.numTrueBitsBefore = function (index) {\n        var countOneBits = function (n) {\n            return n.toString(2).split('0').join('').length;\n        };\n        var ones_count = 0;\n        var max = this.count();\n        if (index > max) {\n            index = max;\n        }\n        // below we iterate over the bytes then over bits (in low endian) and count bits set to 1\n        for (var elem = 0;; elem++) {\n            if (elem * 8 + 7 >= index) {\n                ones_count += countOneBits(this.elems[elem] >> (7 - (index % 8) + 1));\n                return ones_count;\n            }\n            ones_count += countOneBits(this.elems[elem]);\n        }\n    };\n    CompactBitArray.fromData = function (data) {\n        return new CompactBitArray(data.extra_bits_stored, Buffer.from(data.elems, 'base64'));\n    };\n    CompactBitArray.prototype.toData = function () {\n        return {\n            elems: this.elems.toString('base64'),\n            extra_bits_stored: this.extra_bits_stored,\n        };\n    };\n    CompactBitArray.fromProto = function (proto) {\n        return new CompactBitArray(proto.extraBitsStored, Buffer.from(proto.elems));\n    };\n    CompactBitArray.prototype.toProto = function () {\n        return multisig_1.CompactBitArray.fromPartial({\n            elems: this.elems,\n            extraBitsStored: this.extra_bits_stored,\n        });\n    };\n    return CompactBitArray;\n}());\nexports.CompactBitArray = CompactBitArray;\n//# sourceMappingURL=CompactBitArray.js.map"]},"metadata":{},"sourceType":"script"}