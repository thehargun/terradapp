{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MultiSignature = void 0;\n\nvar PublicKey_1 = require(\"./PublicKey\");\n\nvar CompactBitArray_1 = require(\"./CompactBitArray\");\n\nvar SignatureV2_1 = require(\"./SignatureV2\");\n\nvar MultiSignature =\n/** @class */\nfunction () {\n  /**\n   * MultiSignature constructor\n   * public_keys order must be guaranteed\n   */\n  function MultiSignature(multisig_pubkey) {\n    this.multisig_pubkey = multisig_pubkey;\n    var n = multisig_pubkey.pubkeys.length;\n    this.bitarray = CompactBitArray_1.CompactBitArray.fromBits(n);\n    this.signatures = [];\n  }\n\n  MultiSignature.prototype.appendSignature = function (signature_data, index) {\n    var newSigIndex = this.bitarray.numTrueBitsBefore(index); // Signature already exists, just replace the value there\n\n    if (this.bitarray.getIndex(index)) {\n      this.signatures[newSigIndex] = signature_data;\n      return;\n    }\n\n    this.bitarray.setIndex(index, true); // Optimization if the index is the greatest index\n\n    if (newSigIndex == this.signatures.length) {\n      this.signatures.push(signature_data);\n      return;\n    }\n\n    this.signatures.splice(newSigIndex, 0, signature_data);\n  }; // adds a signature to the multisig, at the index in\n  // keys corresponding to the provided pubkey.\n\n\n  MultiSignature.prototype.appendSignatureFromPubKey = function (signature_data, public_key) {\n    var index = this.multisig_pubkey.pubkeys.findIndex(function (v) {\n      return v.key === public_key.key;\n    });\n\n    if (index == -1) {\n      throw new Error(\"provided key doesn't exist in public_keys\");\n    }\n\n    this.appendSignature(signature_data, index);\n  };\n\n  MultiSignature.prototype.appendSignatureV2s = function (signatures) {\n    for (var _i = 0, signatures_1 = signatures; _i < signatures_1.length; _i++) {\n      var signature = signatures_1[_i];\n\n      if (!(signature.public_key instanceof PublicKey_1.SimplePublicKey)) {\n        throw new Error('non-SimplePublicKey cannot be used to sign multisig');\n      }\n\n      this.appendSignatureFromPubKey(signature.data, signature.public_key);\n    }\n  };\n\n  MultiSignature.prototype.toSignatureDescriptor = function () {\n    return new SignatureV2_1.SignatureV2.Descriptor(new SignatureV2_1.SignatureV2.Descriptor.Multi(this.bitarray, this.signatures));\n  };\n\n  return MultiSignature;\n}();\n\nexports.MultiSignature = MultiSignature;","map":{"version":3,"sources":["../../src/core/MultiSignature.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAEA,IAAA,cAAA;AAAA;AAAA,YAAA;AAIE;;;AAGG;AACH,WAAA,cAAA,CAAmB,eAAnB,EAAgE;AAA7C,SAAA,eAAA,GAAA,eAAA;AACjB,QAAM,CAAC,GAAG,eAAe,CAAC,OAAhB,CAAwB,MAAlC;AACA,SAAK,QAAL,GAAgB,iBAAA,CAAA,eAAA,CAAgB,QAAhB,CAAyB,CAAzB,CAAhB;AACA,SAAK,UAAL,GAAkB,EAAlB;AACD;;AAEM,EAAA,cAAA,CAAA,SAAA,CAAA,eAAA,GAAP,UACE,cADF,EAEE,KAFF,EAEe;AAEb,QAAM,WAAW,GAAG,KAAK,QAAL,CAAc,iBAAd,CAAgC,KAAhC,CAApB,CAFa,CAIb;;AACA,QAAI,KAAK,QAAL,CAAc,QAAd,CAAuB,KAAvB,CAAJ,EAAmC;AACjC,WAAK,UAAL,CAAgB,WAAhB,IAA+B,cAA/B;AACA;AACD;;AAED,SAAK,QAAL,CAAc,QAAd,CAAuB,KAAvB,EAA8B,IAA9B,EAVa,CAYb;;AACA,QAAI,WAAW,IAAI,KAAK,UAAL,CAAgB,MAAnC,EAA2C;AACzC,WAAK,UAAL,CAAgB,IAAhB,CAAqB,cAArB;AACA;AACD;;AAED,SAAK,UAAL,CAAgB,MAAhB,CAAuB,WAAvB,EAAoC,CAApC,EAAuC,cAAvC;AACD,GArBM,CAdT,CAqCE;AACA;;;AACO,EAAA,cAAA,CAAA,SAAA,CAAA,yBAAA,GAAP,UACE,cADF,EAEE,UAFF,EAE6B;AAE3B,QAAM,KAAK,GAAG,KAAK,eAAL,CAAqB,OAArB,CAA6B,SAA7B,CACZ,UAAA,CAAA,EAAC;AAAI,aAAA,CAAC,CAAC,GAAF,KAAU,UAAU,CAApB,GAAA;AAAwB,KADjB,CAAd;;AAGA,QAAI,KAAK,IAAI,CAAC,CAAd,EAAiB;AACf,YAAM,IAAI,KAAJ,CAAU,2CAAV,CAAN;AACD;;AAED,SAAK,eAAL,CAAqB,cAArB,EAAqC,KAArC;AACD,GAZM;;AAcA,EAAA,cAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,UAA0B,UAA1B,EAAmD;AACjD,SAAwB,IAAA,EAAA,GAAA,CAAA,EAAA,YAAA,GAAA,UAAxB,EAAwB,EAAA,GAAA,YAAA,CAAA,MAAxB,EAAwB,EAAA,EAAxB,EAAoC;AAA/B,UAAM,SAAS,GAAA,YAAA,CAAA,EAAA,CAAf;;AACH,UAAI,EAAE,SAAS,CAAC,UAAV,YAAgC,WAAA,CAAA,eAAlC,CAAJ,EAAwD;AACtD,cAAM,IAAI,KAAJ,CAAU,qDAAV,CAAN;AACD;;AAED,WAAK,yBAAL,CAA+B,SAAS,CAAC,IAAzC,EAA+C,SAAS,CAAC,UAAzD;AACD;AACF,GARM;;AAUA,EAAA,cAAA,CAAA,SAAA,CAAA,qBAAA,GAAP,YAAA;AACE,WAAO,IAAI,aAAA,CAAA,WAAA,CAAY,UAAhB,CACL,IAAI,aAAA,CAAA,WAAA,CAAY,UAAZ,CAAuB,KAA3B,CAAiC,KAAK,QAAtC,EAAgD,KAAK,UAArD,CADK,CAAP;AAGD,GAJM;;AAKT,SAAA,cAAA;AAAC,CApED,EAAA;;AAAa,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiSignature = void 0;\nvar PublicKey_1 = require(\"./PublicKey\");\nvar CompactBitArray_1 = require(\"./CompactBitArray\");\nvar SignatureV2_1 = require(\"./SignatureV2\");\nvar MultiSignature = /** @class */ (function () {\n    /**\n     * MultiSignature constructor\n     * public_keys order must be guaranteed\n     */\n    function MultiSignature(multisig_pubkey) {\n        this.multisig_pubkey = multisig_pubkey;\n        var n = multisig_pubkey.pubkeys.length;\n        this.bitarray = CompactBitArray_1.CompactBitArray.fromBits(n);\n        this.signatures = [];\n    }\n    MultiSignature.prototype.appendSignature = function (signature_data, index) {\n        var newSigIndex = this.bitarray.numTrueBitsBefore(index);\n        // Signature already exists, just replace the value there\n        if (this.bitarray.getIndex(index)) {\n            this.signatures[newSigIndex] = signature_data;\n            return;\n        }\n        this.bitarray.setIndex(index, true);\n        // Optimization if the index is the greatest index\n        if (newSigIndex == this.signatures.length) {\n            this.signatures.push(signature_data);\n            return;\n        }\n        this.signatures.splice(newSigIndex, 0, signature_data);\n    };\n    // adds a signature to the multisig, at the index in\n    // keys corresponding to the provided pubkey.\n    MultiSignature.prototype.appendSignatureFromPubKey = function (signature_data, public_key) {\n        var index = this.multisig_pubkey.pubkeys.findIndex(function (v) { return v.key === public_key.key; });\n        if (index == -1) {\n            throw new Error(\"provided key doesn't exist in public_keys\");\n        }\n        this.appendSignature(signature_data, index);\n    };\n    MultiSignature.prototype.appendSignatureV2s = function (signatures) {\n        for (var _i = 0, signatures_1 = signatures; _i < signatures_1.length; _i++) {\n            var signature = signatures_1[_i];\n            if (!(signature.public_key instanceof PublicKey_1.SimplePublicKey)) {\n                throw new Error('non-SimplePublicKey cannot be used to sign multisig');\n            }\n            this.appendSignatureFromPubKey(signature.data, signature.public_key);\n        }\n    };\n    MultiSignature.prototype.toSignatureDescriptor = function () {\n        return new SignatureV2_1.SignatureV2.Descriptor(new SignatureV2_1.SignatureV2.Descriptor.Multi(this.bitarray, this.signatures));\n    };\n    return MultiSignature;\n}());\nexports.MultiSignature = MultiSignature;\n//# sourceMappingURL=MultiSignature.js.map"]},"metadata":{},"sourceType":"script"}