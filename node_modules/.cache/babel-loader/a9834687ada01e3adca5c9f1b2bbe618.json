{"ast":null,"code":"import { createContext, useContext } from 'react'; // @ts-ignore\n\nexport const WalletContext = createContext();\nexport function useWallet() {\n  return useContext(WalletContext);\n}","map":{"version":3,"sources":["../../../src/@terra-money/use-wallet/useWallet.ts"],"names":[],"mappings":"AAEA,SAAkB,aAAlB,EAAiC,UAAjC,QAAmD,OAAnD,C,CA0WA;;AACA,OAAO,MAAM,aAAa,GAAoB,aAAa,EAApD;AAEP,OAAM,SAAU,SAAV,GAAmB;AACvB,SAAO,UAAU,CAAC,aAAD,CAAjB;AACD","sourcesContent":["import { TerraWebExtensionFeatures } from '@terra-dev/web-extension-interface';\nimport { CreateTxOptions } from '@terra-money/terra.js';\nimport { Context, createContext, useContext } from 'react';\nimport {\n  Connection,\n  ConnectType,\n  NetworkInfo,\n  SignBytesResult,\n  SignResult,\n  TxResult,\n  WalletInfo,\n  WalletStatus,\n} from './types';\n\nexport interface Wallet {\n  /**\n   * current client status\n   *\n   * this will be one of WalletStatus.INITIALIZING | WalletStatus.WALLET_NOT_CONNECTED | WalletStatus.WALLET_CONNECTED\n   *\n   * INITIALIZING = checking that the session and the chrome extension installation. (show the loading to users)\n   * WALLET_NOT_CONNECTED = there is no connected wallet (show the connect and install options to users)\n   * WALLET_CONNECTED = there is aconnected wallet (show the wallet info and disconnect button to users)\n   *\n   * @see Wallet#refetchStates\n   * @see WalletController#status\n   */\n  status: WalletStatus;\n\n  /**\n   * current selected network\n   *\n   * - if status is INITIALIZING or WALLET_NOT_CONNECTED = this will be the defaultNetwork\n   * - if status is WALLET_CONNECTED = this depends on the connected environment\n   *\n   * @see WalletProviderProps#defaultNetwork\n   * @see WalletController#network\n   */\n  network: NetworkInfo;\n\n  /**\n   * available connect types on the browser\n   *\n   * @see Wallet#connect\n   * @see WalletController#availableConnectTypes\n   */\n  availableConnectTypes: ConnectType[];\n\n  /**\n   * available connections includes identifier, name, icon\n   *\n   * @example\n   * ```\n   * const { availableConnections, connect } = useWallet()\n   *\n   * return (\n   *  <div>\n   *    {\n   *      availableConnections.map(({type, identifier, name, icon}) => (\n   *        <butotn key={`${type}:${identifier}`} onClick={() => connect(type, identifier)}>\n   *          <img src={icon} /> {name}\n   *        </button>\n   *      ))\n   *    }\n   *  </div>\n   * )\n   * ```\n   */\n  availableConnections: Connection[];\n\n  /**\n   * connect to wallet\n   *\n   * @example\n   * ```\n   * const { status, availableConnectTypes, connect } = useWallet()\n   *\n   * return status === WalletStatus.WALLET_NOT_CONNECTED &&\n   *        availableConnectTypes.includs(ConnectType.EXTENSION) &&\n   *  <button onClick={() => connect(ConnectType.EXTENSION)}>\n   *    Connct Chrome Extension\n   *  </button>\n   * ```\n   *\n   * @see Wallet#availableConnectTypes\n   * @see WalletController#connect\n   */\n  connect: (type: ConnectType, identifier?: string) => void;\n\n  /**\n   * manual connect to read only session\n   *\n   * @see Wallet#connectReadonly\n   */\n  connectReadonly: (terraAddress: string, network: NetworkInfo) => void;\n\n  /**\n   * available install types on the browser\n   *\n   * in this time, this only contains [ConnectType.EXTENSION]\n   *\n   * @see Wallet#install\n   * @see WalletController#availableInstallTypes\n   */\n  availableInstallTypes: ConnectType[];\n\n  /**\n   * install for the connect type\n   *\n   * @example\n   * ```\n   * const { status, availableInstallTypes } = useWallet()\n   *\n   * return status === WalletStatus.WALLET_NOT_CONNECTED &&\n   *        availableInstallTypes.includes(ConnectType.EXTENSION) &&\n   *  <button onClick={() => install(ConnectType.EXTENSION)}>\n   *    Install Extension\n   *  </button>\n   * ```\n   *\n   * @see Wallet#availableInstallTypes\n   * @see WalletController#install\n   */\n  install: (type: ConnectType) => void;\n\n  /**\n   * connected wallets\n   *\n   * this will be like\n   * `[{ connectType: ConnectType.WALLETCONNECT, terraAddress: 'XXXXXXXXX' }]`\n   *\n   * in this time, you can get only one wallet. `wallets[0]`\n   *\n   * @see WalletController#wallets\n   */\n  wallets: WalletInfo[];\n\n  /**\n   * disconnect\n   *\n   * @example\n   * ```\n   * const { status, disconnect } = useWallet()\n   *\n   * return status === WalletStatus.WALLET_CONNECTED &&\n   *  <button onClick={() => disconnect()}>\n   *    Disconnect\n   *  </button>\n   * ```\n   */\n  disconnect: () => void;\n\n  /**\n   * reload the connected wallet states\n   *\n   * in this time, this only work on the ConnectType.EXTENSION\n   *\n   * @see WalletController#refetchStates\n   */\n  refetchStates: () => void;\n\n  /**\n   * @deprecated please use refetchStates(). this function will remove on next major update\n   */\n  recheckStatus: () => void;\n\n  /**\n   * support features of this connection\n   *\n   * @example\n   * ```\n   * const { supportFeatures } = useWallet()\n   *\n   * return (\n   *  <div>\n   *    {\n   *      supportFeatures.has('post') &&\n   *      <button onClick={post}>post</button>\n   *    }\n   *    {\n   *      supportFeatures.has('cw20-token') &&\n   *      <button onClick={addCW20Token}>add cw20 token</button>\n   *    }\n   *  </div>\n   * )\n   * ```\n   */\n  supportFeatures: Set<TerraWebExtensionFeatures>;\n\n  /**\n   * post transaction\n   *\n   * @example\n   * ```\n   * const { post } = useWallet()\n   *\n   * const callback = useCallback(async () => {\n   *   try {\n   *    const result: TxResult = await post({...CreateTxOptions})\n   *    // DO SOMETHING...\n   *   } catch (error) {\n   *     if (error instanceof UserDenied) {\n   *       // DO SOMETHING...\n   *     } else {\n   *       // DO SOMETHING...\n   *     }\n   *   }\n   * }, [])\n   * ```\n   *\n   * @param { CreateTxOptions } tx transaction data\n   * @param terraAddress - does not work at this time. for the future extension\n   *\n   * @return { Promise<TxResult> }\n   *\n   * @throws { UserDenied } user denied the tx\n   * @throws { CreateTxFailed } did not create txhash (error dose not broadcasted)\n   * @throws { TxFailed } created txhash (error broadcated)\n   * @throws { Timeout } user does not act anything in specific time\n   * @throws { TxUnspecifiedError } unknown error\n   *\n   * @see WalletController#post\n   */\n  post: (tx: CreateTxOptions, terraAddress?: string) => Promise<TxResult>;\n\n  /**\n   * sign transaction\n   *\n   * @example\n   * ```\n   * const { sign } = useWallet()\n   *\n   * const callback = useCallback(async () => {\n   *   try {\n   *    const result: SignResult = await sign({...CreateTxOptions})\n   *\n   *    // Broadcast SignResult\n   *    const tx = result.result\n   *\n   *    const lcd = new LCDClient({\n   *      chainID: connectedWallet.network.chainID,\n   *      URL: connectedWallet.network.lcd,\n   *    })\n   *\n   *    const txResult = await lcd.tx.broadcastSync(tx)\n   *\n   *    // DO SOMETHING...\n   *   } catch (error) {\n   *     if (error instanceof UserDenied) {\n   *       // DO SOMETHING...\n   *     } else {\n   *       // DO SOMETHING...\n   *     }\n   *   }\n   * }, [])\n   * ```\n   *\n   * @param { CreateTxOptions } tx transaction data\n   * @param terraAddress - does not work at this time. for the future extension\n   *\n   * @return { Promise<SignResult> }\n   *\n   * @throws { UserDenied } user denied the tx\n   * @throws { CreateTxFailed } did not create txhash (error dose not broadcasted)\n   * @throws { TxFailed } created txhash (error broadcated)\n   * @throws { Timeout } user does not act anything in specific time\n   * @throws { TxUnspecifiedError } unknown error\n   *\n   * @see WalletController#sign\n   */\n  sign: (tx: CreateTxOptions, terraAddress?: string) => Promise<SignResult>;\n\n  /**\n   * sign any bytes\n   *\n   * @example\n   * ```\n   * const { signBytes } = useWallet()\n   *\n   * const BYTES = Buffer.from('hello world')\n   *\n   * const callback = useCallback(async () => {\n   *   try {\n   *     const { result }: SignBytesResult = await signBytes(BYTES)\n   *\n   *     console.log(result.recid)\n   *     console.log(result.signature)\n   *     console.log(result.public_key)\n   *\n   *     const verified: boolean = verifyBytes(BYTES, result)\n   *   } catch (error) {\n   *     if (error instanceof UserDenied) {\n   *       // DO SOMETHING...\n   *     } else {\n   *       // DO SOMETHING...\n   *     }\n   *   }\n   * }, [])\n   * ```\n   *\n   * @param bytes\n   */\n  signBytes: (bytes: Buffer, terraAddress?: string) => Promise<SignBytesResult>;\n\n  /**\n   * check if tokens are added on the extension\n   *\n   * @param chainID\n   * @param tokenAddrs cw20 token addresses\n   *\n   * @return token exists\n   *\n   * @see WalletController#hasCW20Tokens\n   */\n  hasCW20Tokens: (\n    chainID: string,\n    ...tokenAddrs: string[]\n  ) => Promise<{ [tokenAddr: string]: boolean }>;\n\n  /**\n   * request add token addresses to browser extension\n   *\n   * @param chainID\n   * @param tokenAddrs cw20 token addresses\n   *\n   * @return token exists\n   *\n   * @see WalletController#addCW20Tokens\n   */\n  addCW20Tokens: (\n    chainID: string,\n    ...tokenAddrs: string[]\n  ) => Promise<{ [tokenAddr: string]: boolean }>;\n\n  /**\n   * check if network is added on the extension\n   *\n   * @param network\n   *\n   * @return network exists\n   *\n   * @see WalletController#hasNetwork\n   */\n  hasNetwork: (network: Omit<NetworkInfo, 'name'>) => Promise<boolean>;\n\n  /**\n   * request add network to browser extension\n   *\n   * @param network\n   *\n   * @return network exists\n   *\n   * @see WalletController#addNetwork\n   */\n  addNetwork: (network: NetworkInfo) => Promise<boolean>;\n\n  /**\n   * Some mobile wallet emulates the behavior of chrome extension.\n   * It confirms that the current connection environment is such a wallet.\n   * (If you are running connect() by checking availableConnectType, you do not need to use this API.)\n   */\n  isChromeExtensionCompatibleBrowser: () => boolean;\n}\n\n// @ts-ignore\nexport const WalletContext: Context<Wallet> = createContext<Wallet>();\n\nexport function useWallet(): Wallet {\n  return useContext(WalletContext);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}